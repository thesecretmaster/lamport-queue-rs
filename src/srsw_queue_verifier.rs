use std::time;

// Wrap internal thread state logic in a module to prevent anything using
// enum constructors besides `Ready`. All of the other constructors will
// break things if used outside.
//
// This module abstracts out the common logic shared between the sender
// and reciever threads. It manages the data that the thread uses (a list
// to read from for the sender and a list to write to for the reciever)
// and the life cycle of the threads, from spawn to waiting for termination.
mod thread_state {
    use std::thread;
    use std::mem;
    use std::time;

    // The reason for {Pre,Post}run is because of how we spawn and join threads. We need
    // to pass in ownership of the list before we get a handle back (or we need ownership
    // of the handle before we can store the list). This requires very brief transition
    // states, so we have them.
    enum ThreadStateE<T> {
        Ready(T),
        Prerun,
        Running(thread::JoinHandle<(T, time::Instant)>),
        Postrun
    }

    pub struct ThreadState<T>(ThreadStateE<T>);

    use ThreadStateE::*;

    pub type ThreadRet<T> = (T, time::Instant);

    impl<T: 'static + Clone + Send> ThreadState<T> {
        // Expose the Ready enum constructor
        pub fn new(t: T) -> Self {
            ThreadState(Ready(t))
        }

        // Wrap the `thread::spawn` function, hands ownership of the thread's
        // list into the thread and sets up a return value that `join` can use
        pub fn run_thread<F: 'static + FnOnce(T) -> ThreadRet<T> + Send>(&mut self, f: F) -> Result<(), &'static str> {
            // Argh this is so ugly
            let l = if matches!(self.0, Ready(_)) {
                // This will always be true because we've just checked if it's Ready
                // and we have exclusive access (&mut)
                if let Ready(l) = mem::replace(&mut self.0, Prerun) {
                    Some(l)
                } else { None }
            } else { None }.ok_or("Only one reciever can be started for each verifier")?;

            // Spawn thread and store handle so we can wait later
            self.0 = Running(thread::spawn(move || f(l)));
            Ok(())
        }

        // Wrap the `thread::JoinHandle` function, re-build the state so that
        // it can be reused for future tests.
        pub fn join(&mut self) -> Result<ThreadRet<T>, &'static str> {
            let h = mem::replace(&mut self.0, Postrun);
            if let Running(handle) = h {
                // We can use unwrap here because if the thread can't be joined that's unrecoverable
                let (l, t) = handle.join().unwrap();
                self.0 = Ready(l.clone());
                Ok((l, t))
            } else {
                Err("Thread has not been started yet")
            }
        }

        // Makes a copy of a prepaired test run
        // This cannot overlap with a running test, because while
        // a test is running the data that we would need to copy
        // is owned by that thread.
        pub fn clone(&self) -> Result<Self, &'static str> {
            match &self.0 {
                Ready(l) => Ok(ThreadState(Ready(l.clone()))),
                _ => Err("Can't clone a running test")
            }
        }
    }
}

use thread_state::ThreadState;

pub struct VerificationChecker<T> {
    list_size: usize,
    send_thread_state: ThreadState<Box<[T]>>, // Manages the send_list and send thread
    recieve_thread_state: ThreadState<Vec<T>>, // Manages the recieve_list and recieve thread
}

impl<T: 'static + Default + Copy + PartialEq + Send> VerificationChecker<T> {
    pub fn new<F: FnMut(&mut T)>(list_size: usize, f: F) -> Self {
        // Populate a boxed slice with random numbers generated by `f`
        let mut v: Box<[T]> = vec![T::default(); list_size].into_boxed_slice();
        v.iter_mut().for_each(f);

        Self {
            list_size,
            send_thread_state: ThreadState::new(v),
            recieve_thread_state: ThreadState::new(Vec::with_capacity(list_size)),
        }
    }

    // Creates an equivilent but fresh VerificationChecker. Specifically, the list elements
    // that are sent will remain the same and be in the same order.
    //
    // We could share the list itself using Arc, however this could give later tests an advantage
    // over earlier tests by having the caches start hot.
    pub fn clone_send(&self) -> Self {
        let send_thread_state = self.send_thread_state.clone().expect("Can't clone a running test");
        let recieve_thread_state = self.recieve_thread_state.clone().expect("Can't clone a running test");
        Self {
            list_size: self.list_size,
            send_thread_state,
            recieve_thread_state,
        }
    }

    // Wait for our test to terminate, conclude timing, print results
    //
    // A possible improvment here would be to seperate output printing/handling
    // from the test ending and timing.
    pub fn verify(&mut self) -> bool {
        // Wait for both threads to terminate
        let (send_list, start_time) = self.send_thread_state.join().expect("Cannot verify if a sender thread hasn't been started");
        let (recieve_list, end_time) = self.recieve_thread_state.join().expect("Cannot verify if a reciever thread hasn't been started");

        // End the benchmark
        let duration = end_time.duration_since(start_time);

        // Run correctness checks
        let same_length = send_list.len() == recieve_list.len();
        let mut numbers_match = true;
        for i in 0..self.list_size {
            if send_list[i] != recieve_list[i] {
                numbers_match = false;
                break;
            }
        }

        println!("Count is correct? {}", same_length);
        println!("Numbers match up? {}", numbers_match);
        println!("Elapsed time: {}ms", duration.as_millis());

        same_length && numbers_match
    }

    pub fn run_sender<F: 'static + FnOnce(&Box<[T]>) + Send>(&mut self, f: F) {
        self.send_thread_state.run_thread(|sl| {
            let start_time = time::Instant::now();
            f(&sl);
            (sl, start_time)
        }).expect("Sender has already been started and a test is in progress");
    }

    pub fn run_reciever<F: 'static + FnOnce(&mut Vec<T>) + Send>(&mut self, f: F) {
        self.recieve_thread_state.run_thread(|mut rl| {
            f(&mut rl);
            let end_time = time::Instant::now();
            (rl, end_time)
        }).expect("Reciever has already been started and a test is in progress");
    }
}
